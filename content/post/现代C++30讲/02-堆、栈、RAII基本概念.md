---
title: "02-堆、栈、RAII基本概念"
subtitle:
summary:
authors:
tags:
- c++
categories:
- 现代C++实战30讲
date: 2019-12-20T23:25:15+08:00
lastmod: 2019-12-20T23:25:15+08:00
featured: false
draft: false
---

本文为课程笔记：[https://time.geekbang.org/column/article/169225](https://time.geekbang.org/column/article/169225)

上一篇中我还特意提到了编译器的选择， 实际上本专栏正式开始前，有一篇关于编译器的介绍，这可真是目录都没看，就开始"翻书"了。

前面也提到了，目录都没细看，直接开始听稿子，没想到第一讲说的居然是堆、栈。

 - 堆：`heap`，在内存管理中，指的是动态分配的内存，`new delete malloc free`
 - 栈：`stack`，函数调用过程中的本地变量和调用数据的区域

![堆栈1](堆栈1.png)

`RAII`在我看来属于`C++`的内存管理方式，配合析构函数，对象对于外部而言并没有直接内存相关的操作。

### 堆

```
auto ptr = new std::vector<int>();
```

**由于动态分配内存存在不确定性**，在特定的场合，会禁用动态分配：飞行控制器和电信设备

最新正好在开发一个和行情相关的项目，为了提高性能，能说一句恰逢其时？`C11`的智能指针效率，**存在纳秒级别的性能损耗**。

程序开发时，三个常见的内存操作：
- 让内存管理器分配一个某个大小的内存
- 让内存管理器释放一个之前分配的内存块
- 让内存管理器进行垃圾回收，寻找不再使用的内存块并进行释放

`C++`通常做前面两步，`java`通常做1和3。不同的语言有着不同的实现方式。

释放内存不只是简单地把内存标记为已未使用。对于连续使用的内存块，通常内存管理器需要将其合并成一块，一遍满足后续大的内存分配申请。
**目前的编程模式都要求申请的内存块是连续的**。

### 栈

- 栈上的分配极为简单，移动一下栈指针
- 栈上的释放也简单，函数执行结束是，移动一下栈指针即可
- 由于后劲先出的执行过程，不可能出现内存碎片    